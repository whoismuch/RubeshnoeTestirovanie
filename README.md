# RubeshnoeTestirovanie

## Билет №1

###  LESS / SASS / SCSS. Особенности, отличия, поддержка браузерами

####LESS

__LESS__ - это динамический язык стилей, который является надстройкой над CSS (Поэтому любой CSS код будет валидный LESS).

Приемущества LESS:

1. Переменные (и области видимости переменных).
2. Операции (в том числе и для управления цветом, т.е можно смешивать цвета: #941f1f + #222222).
3. И другие функции для работы с цветом (осветление, затемнение и т.п.)
4. Вложенность (можно вложить одно правило в другое, article.post p {} <=> article.post { p{ }}).
5. Объединение аргуметов.

LESS-файл конвертируется в CSS при помощи js (для этого необходимо скачать less.js с сайта LESS).

####SASS

__Sass__ - это метаязык на основе CSS, предназначенный для увеличения уровня абстракции CSS кода и упрощения файлов каскадных таблиц стилей.

Приемущества Sass:

1. Вложенные правила.
2. Переменные.
3. Возможность создавать миксины, позволяющие создавать многоразовые CSS-правила - группы деклараций, для многократного использования. (LESS в это не может)
4. Расширения. Одиночный селектор может быть расширен больше, чес одним селектором с помошью @extend.
5. Есть логика. (if/then/for). (Этого в LESS тоже нет)


Не может компилироватся на сервере в CSS (LESS использует js).
Браузер не распознает файлы Sass, так что сначала их нужно скомпилировать в обычный CSS.

####SCSS

__SCSS__ — "диалект" языка SASS. Отличие SCSS от SASS заключается в том, что SCSS больше похож на обычный CSS код.

1. @import - @import "template" подключит template.scss.
2. Вложенность.
3. $переменные.
4. Математика чисел и цветов.
5. Строки (умеет складвать строки, поддерживает конструкцию #{$var})

Файлы, заканчивающиеся на .scss представляют собой стандартный синтаксис, поддерживаемый Sass. SCSS - это надмножество CSS. Файлы, заканчивающиеся на .sass представляют собой "старый" синтаксис, поддерживаемый Sass, происходящим в мире ruby.

###Java SE, Java EE, Java ME. Платформа Java EE, понятие контейнера и компонента

- Java SE — основные инструменты и библиотеки языка
- Java EE — платформа для enterprise серверных приложений (JSP, JSF, сервлеты и т.д.)
- Java ME — урезанная платформа для мобильных устройств (в основном использовалась до появления iOS/Android)

####Контейнер
Сервлеты — серверные сценарии, жизненным циклом которых управляет веб-контейнер. Существует несколько веб-контейнеров (Apache Tomcat, GlassFish, Jetty, др.); они все реализуют определенный стандарт Java EE (6/7/8).

__Сервлет-контейнер__ поддерживает только API сервлета (включая JSP, JSTL).
Сервер приложений поддерживает весь JavaEE - EJB, JMS, CDI, JTA, API сервлета (включая JSP, JSTL) и т.д.

####Архитектура JavaEE
1. При запуске веб-контейнер читает манифест (web.xml) приложения и создает для него ServletContext. Для каждого класса сервлета и фильтра из манифеста создается объект. Контекст и объекты фильтров/сервлетов будут жить на протяжении работы приложения, т.е. одна и та же инстанция будет использоваться для всех запросов и сессий.

2. При поступлении HTTP запроса веб-контейнер создает новые объекты HttpServletRequest и HttpServletResponse и передает их фильтрам, потом сервлету.

####Компонент
Компонент пользовательского интерфейса JSF является основным строительным блоком для создания пользовательского интерфейса JSF. Конкретный компонент представляет собой настраиваемый и многоразовый элемент в пользовательском интерфейсе, который может варьироваться от простой (например, кнопки или текстового поля) до составного (например, дерева управления или таблицы).

###Структура HTTP запроса, передающего логин и пароль пользователя
```http request
POST /login.cgi HTTP/1.1
Host: www.vk.com

login=hello&password=chmo
```

##Билет 2

###ESMAScript - особенности, типы данных, инструкции.

__ECMAScript__ — это встраиваемый расширяемый не имеющий средств ввода-вывода язык программирования, используемый в качестве основы для построения других скриптовых языков. Стандартизирован международной организацией ECMA в спецификации. (ECMAScript это стандарт, а JavaScript его реализация).

Имеет 5 примитивных типов данных — Number, String, Boolean, Null и Undefined; Объектный тип данных — Object и 15 различных видов инструкций.

В особенности можно добавить то, что блок не ограничивает область видимости функции. Если переменная объявляется вне функции, то она попадает в глобальную область видимости. Функция — это тоже объект.

####ES6
Это обновление добавило новый синтаксис для написания классов и модулей, добавились итераторы и циклы for/of, Python-style генераторы, двоичные данные, лямбда-выражения, типизированные массивы, коллекции, обещания (promises), рефлексию и прокси, усовершенствовали числа и математику. Добавлено ключевое слово let (которое помогает объявить переменной область видимости - блок) и const.

####ES7
Добавлена операция возведения в степень (**), Array.prototype.includes().

###Правила трансляции JSP

При загрузке в веб-контейнер страницы JSP транслируются компилятором (jasper) в сервлеты.

Во время фазы трансляции контейнер локализует или создаёт класс реализации JSP-страницы, соответствующий данной JSP-странице. Этот процесс определяется семантикой JSP-страницы. Контейнер интерпретирует имеющиеся на этой странице стандартные директивы и акции и специальные акции, ссылающиеся на библиотеки тэгов. Библиотека тэгов может по выбору представлять метод проверки корректности использования на JSP-странице данной библиотеки.

###Написать код HTML-страницы, отправляющей номер вопроса и выбранный вариант ответа (латинская буква от “A” до “F”) после получения некоего текста.
   
Что это за дичь???

##Билет 3

###Методы HTTP

####Методы запросов:

- Метода GET в HTTP используется для получения информации от сервера по заданному URI (URI в HTTP). Запросы клиентов, использующие метод GET должны получать только данные и не должны никак влиять на эти данные. Сервер кэширует ответы

- HTTP метод HEAD работает точно так же, как GET, но в ответ сервер посылает только заголовки и статусную строку без тела HTTP сообщения. (используется для получения метаинформации об объекте без пересылки тела HTTP сообщения) (Метод HEAD часто используется для тестирования HTTP соединений и достижимости узлов и ресурсов, так как нет необходимости гонять по сети содержимое, тестирование HTTP методом HEAD производится гораздо быстрее.) Сервер может кэшировать ответы

- HTTP метод POST используется для отправки данных на сервер, например, из HTML форм, которые заполняет посетитель сайта. Сервер НЕ кэширует ответы

- HTTP метод PUT используется для загрузки содержимого запроса на указанный в этом же запросе URI. (метод POST и метод PUT выполняют совершенно разные операции. Метод POST обращается к ресурсу (странице или коду), которая содержит механизмы обработки сообщения метода POST, а вот метод PUT создает какой-то объект по URI, указанному в сообщение с HTTP методом PUT.)

- HTTP метод PUTCH Аналогичен PUT, но применяется к фрагменту ресурса

- HTTP метод DELETE удаляет указанный в URI ресурс.

- HTTP метод CONNECT преобразует существующее соединение в тоннель. (HTTP метод CONNECT используется для преобразования HTTP соединения в прозрачный TCP/IP туннель. Пожалуй, это всё, что можно сказать про HTTP метод CONNECT в контексте рассматриваемого протокола, разве что стоит добавить, что данный метод используется в основном для шифрования соединения (не путайте с кодировкой сообщений).)

- HTTP метод OPTIONS используется для получения параметров текущего HTTP соединения.

- HTTP метод TRACE создает петлю, благодаря которой клиент может увидеть, что происходит с сообщением на всех узлах передачи. (HTTP метод TRACE применяется для диагностики, он позволяет видеть клиенту, что происходит в каждом звене цепочки между компьютером клиента и конечным получателем)

###Жизненный цикл сервлета

- Жизненным циклом сервлета управляет вебконтейнер.
- Методы, управляющие жизненным циклом, должен вызывать только веб-контейнер.

1. Загрузка класса сервлета.
( Проверяются пути: /WEB-INF/classes/, WEB-INF/lib/*.jar, стандартные
классы Java SE и классы веб-контейнера )

2. Создание экземпляра сервлета.

3. Вызов метода init.

4. Обработка HTTP-запросов.

5. Вызов метода destroy.

Для каждого сервлета движок сервлетов создает только одну копию. Вне зависимости от того, сколько запросов будет отправлено сервлету, все запросы будут обрабатываться толькой одной копией сервлета. Объект сервлета создается либо при запуске движка сервлетов, либо когда сервлет получает первый запрос. Затем для каждого запроса запускается поток, который обращается к объекту сервлета.

При работе с сервлетом движок сервлетов вызывает у класса сервлета ряд методов, которые определены в родительском абстрактном классе HttpServlet.

Когда движок сервлетов создает объект сервлета, у сервлета вызывается метод init().

public void init(ServletConfig config) throws ServletException { 
}
Этот метод вызывается только один раз - при создании сервлета. Мы можем переопределить этот метод, чтобы определить в нем некоторую логику инициализации.

Когда к сервлету приходит запрос, движок сервлетов вызывает метод service() сервлета. А этот метод, исходя из типа запроса (GET, POST, PUT и т.д.) решает, какому методу сервлета (doGet, doPost и т.д.) обрабатывать этот запрос.

public void service(HttpServletRequest request, HttpServletResponse response) 
        throws IOException, ServletException{
        }
Этот метод также можно переопределить, однако в этом нет смысла. В реальности для обработки запроса переопределяются методы onGet, onPost и т.д., которые обрабатывают конкретные типы запросов.

Если объект сервлета долгое время не используется (к нему нет никаких запросов), или если происходит завершение работы движка сервлетов, то движок сервлетов выгружает из памяти все созданные экземпляры сервлетов. Однако до выгрузки сервлета из памяти у сервлета вызывается метод destroy().

public void destroy()
При необходимости мы также можем его переопределить, например, определить в нем логику логгирования или что иное. В то же время следует учитывать, что если сервер вдруг упадет по какой-то причине, например, отключится электричество и т.д., тогда данный метод естественно не будет вызван и его логика не сработает.

Поскольку для обработки всех запросов создается один экземпляр сервлета, и все обращения к нему идут в отдельных потоках, то не рекомендуется в классе сервлета объявлять и использовать глобальные переменные, так как они не будут потокобезопасными.

###Написать на JS функцию, которая на странице заменяет все текстовые поля ввода на кнопки

```js
// замена всех текстовых полей ввода на кнопку
function replaceAllTextInputs(){
    Array.from(document.querySelectorAll("input[type=text], textarea"))
        .forEach(input => {
        	var button = document.createElement('button');
    		button.innerHTML = "I am button";
        	input.replaceWith(button);
         });
}
```

##Билет 4 

###Коды состояния HTTP 

__Код ответа (состояния) HTTP__ показывает, был ли успешно выполнен определённый HTTP запрос. Коды сгруппированы в 5 классов:

1. Информационные 100 - 199
2. Успешные 200 - 299
3. Перенаправления 300 - 399
4. Клиентские ошибки 400 - 499
5. Серверные ошибки 500 - 599

###Фильтры запросов. Реализация пред и пост обработки запросов

Сервлетный фильтр занимается предварительной обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа, исходящего из сервлета.

Сервлетные фильтры могут:

- Перехватывать инициацию сервлета прежде, чем сервлет будет инициирован;
- Определить содержание запроса прежде, чем сервлет будет инициирован;
- Модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;
- Модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ; 
- Перехватывать инициацию сервлета после обращения к сервлету. Основой для формирования фильтров служит интерфейс javax.servlet.Filter, который реализует три метода:

```xml
<filter>
    <filter-name>FilterName</filter-name>
    <filter-class>common.FilterConnect</filter-class>
    <init-param>
        <param-name>active</param-name>
        <param-value>true</param-true>
    </init-param>
</filter>
 
<filter-mapping>
    <filter-name>FilterName</filter-name>
    <servlet-name>ServletName</servlet-name>
</filter-mapping>
```
```java

public void init (FilterConfig config) throws ServletException {};

public void destroy () {};

public void doFilter (ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;
```

Пример предобработки:

```java
if (userAuthorized()) {
    chain.doFilter(request, response);  
} else { 
    httpResponse.sendRedirect("login.jsp");
}
```

Пример постобработки Чтобы манипулировать ответами от сервера, прежде чем они будут отправлены обратно клиенту.

###Написать css правило, которое повернёт все картинки в форме с id=sampleForm на 90 градусов по часовой стрелке

```css
#sampleForm img {
transform: rotate(90deg);
}
```

##Билет 5

### 1. Структура Html-документа

DOM – это объектное представление исходного HTML-документа, попытка преобразовать его структуру и содержимое в объектную модель, с которой смогли бы работать различные программы.

В ближайшем приближении DOM – это "дерево узлов" (node tree). У него единый корень, который разветвляется на множество дочерних ветвей, каждая из которых может ветвиться сама и заканчивается "листьями". Корень – это элемент html, а ветви – вложенные элементы.

Модификация с помощью JavaScript DOM позволяет не только просматривать содержимое страницы, но и взаимодействовать с ним, изменять. Это не статичное отображение, а живой ресурс.

Например, с помощью JavaScript можно создать дополнительные элементы:

```js
var newParagraph = document.createElement("p"); 
var paragraphContent = document.createTextNode("I'm new!"); 
newParagraph.appendChild(paragraphContent); 
document.body.appendChild(newParagraph);
```

Document метод querySelector() возвращает первый элемент (Element) документа, который соответствует указанному селектору или группе селекторов. Если совпадений не найдено, возвращает значение null.

Основные характеристики объектной модели:

- основана на валидном HTML-коде;
- может быть модифицирована из JavaScript;
- не включает псевдоэлементы, созданные из CSS;
- включает скрытые элементы (display: none).
- Объектная модель документа – очень полезная штука. Благодаря ей JavaScript может взаимодействовать со страницей, изменять ее содержимое, структуру и стили. Именно благодаря DOM вы можете отслеживать клиентские события.

DOM – понятие, специфичное для браузерной среды выполнения кода. Это не JavaScript, а лишь API, которым JavaScript может пользоваться.

###2. Servlet - особенности, отличия от CGI/ FastCGI

Servlet – в первую очередь это простой Java интерфейс, реализация которого расширяет функциональные возможности сервера. Сервлет взаимодействует с клиентами посредством принципа запрос-ответ.

__Что же такое сервлет ? В двух словах описать работу сервлета можно так:__

На сервер приходит запрос от клиента, запрос содержит внутри себя URL и параметры. Сервер имеет специальный конфигурационный файл, который ему сообщает о том, какой сервлет надо выполнить в случае прихода определенного URL. Сервлет выполняется (там вы можете использовать параметры) и создает HTML-страницу, которая отсылается клиенту. Сервер по сути является контейнером (теперь уже не визуальных компонентов), который загружает сервлеты, выполняет их, вызывая определенные методы и получив от них результат, отправляет его клиенту.

Таким образом сервлет — это Java-класс, который наследуется обычно от класса • HttpServlet и переопределяет часть методов:

- doGet — если мы хотим, чтобы сервлет реагировал на GET запрос.
- doPost — если мы хотим, чтобы сервлет реагировал на POST запрос.
- doPut, doDelete — если мы хотим, чтобы сервлет реагировал на PUT и DELETE запрос (есть и такие в HTTP). Эти методы реализуются крайне редко, т.к. сами команды тоже очень редко встречаются.
- init, destroy — для управления ресурсами в момент создания сервлета и в момент его уничтожения.

Если же необходимо перехватывать все команды, то проще переопределить метод service. Именно этот метод вызывается при приходе запроса от клиента. В HttpServlet происходит разбор запроса и в соответствии с указанной командой вызывается метод doGet, doPost и т.д.

Важно !!!

- ServletContext живет до тех пор, пока живет веб-приложение. Он является общим для всех запросов во всех сеансах.
- HttpSession живет до тех пор, пока клиент взаимодействует с веб-приложением с одним и тем же экземпляром браузера, а время ожидания сеанса на стороне сервера не истекло. Он является общим для всех запросов в одном сеансе.
- HttpServletRequest и HttpServletResponse живут с момента получения сервлетом запроса HTTP от клиента, пока не будет получен полный ответ (веб-страница). Он не разделяется в других местах.
- Все экземпляры Servlet , Filter и Listener живут до тех пор, пока живет веб-приложение. Они являются общими для всех запросов во всех сеансах.
- Любой attribute , определенный в ServletContext, HttpServletRequest и HttpSession , будет жить до тех пор, пока живет рассматриваемый объект. Сам объект представляет собой "scope" в рамках управления бобами, таких как JSF, CDI, Spring и т.д. Эти фреймворки хранят свои ограниченные бобы как attribute из своей ближайшей совпадающей области.

####Преимущества и недостатки относительно CGI и FastCGI

Преимущества:

- Выполняются быстрее, чем CGI-сценарии.
- Хорошая масштабируемость.
- Надежность и безопасность (реализованы на JAVA)
- Платформенно-независимы
- Множество инструментов мониторинга и отладки
- Поскольку для каждого запроса существует новый процесс, это означает, что CGI не может агрегировать данные из нескольких запросов в памяти.

Недостатки:

- Слабое разделение уровня представления и бизнес-логики.
- Возможны конфликты при параллельной обработке запрос
ов.

###3. Написать CSS правило, которое будет обводить все картинки в классе news в рамку при наведении мышю

```css
.news img:hover {
border: 3px solid red;
}
```
## Билет 6

###1. Super Agent 

Библиотека Superagent, как и Axios, подходит для Node.js и для современных браузеров. Она предоставляет разработчику простое и понятное API, с которым удобно работать.

####Что такое Node.js?
Node.js (или просто Node) — это серверная платформа для работы с JavaScript через движок V8. JavaScript выполняет действие на стороне клиента, а Node — на сервере. С помощью Node можно писать полноценные приложения. Node умеет работать с внешними библиотеками, вызывать команды из кода на JavaScript и выполнять роль веб-сервера.

####В чём преимущество Node?
C Node проще масштабироваться. При одновременном подключении к серверу тысяч пользователей Node работает асинхронно, то есть ставит приоритеты и распределяет ресурсы грамотнее. Java же, например, выделяет на каждое подключение отдельный поток.

#### Откуда Node вообще взялся?
Node появился в 2009 году благодаря Райану Далу. До этого в серверах царил подход «один поток на каждое соединение», а Дал придумал использовать систему, которая ориентирована на события. То есть реагирует на действие или бездействие и выделяет под это ресурс. Главная цель Node — построение масштабируемых сетевых серверов.

SuperAgent позиционируется разработчиками как легковесная и расширяемая библиотека для работы с AJAX. Для того чтобы выполнить HTTP-запрос средствами Superagent, достаточно вызвать подходящий метод объекта request:

```js
request.post('/api/pet') 
.send({ name: 'Manny', species: 'cat' }) 
.set('X-API-Key', 'foobar') 
.set('Accept', 'application/json') 
.then(res =>{ console.log('I got: ' + JSON.stringify(res.body)); })
.catch(error => { console.log("Something wrong", errror); });
```

#### ▍Сильные стороны
- Поддерживает плагины.
- Поддаётся конфигурированию.
- Имеет приятный интерфейс для выполнения HTTP-запросов. 
- Поддерживает объединение в цепочку нескольких вызовов для выполнения запросов. 
- Работает в среде Node.js и в браузерах. 
- Поддерживает индикацию прогресса для выгрузки и загрузки данных. 
- Поддерживает механизм chunked-transfer encoding.
- Поддерживает коллбэки. 
- Для этой библиотеки разработано множество плагинов.

Плагин - это расширение, которое улучшает возможности приложения, а библиотека - это набор классов и функций, которые помогают разрабатывать программное обеспечение.

#### ▍Слабые стороны
Имеет своеобразное API, не придерживающееся каких-либо стандартов.

###2. Шаблоны проектирования, архитектурные, для чего нужны, разница

__Шаблон проектирования или паттерн__ — повторимая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста (© Wikipedia).

- Описывает подход к решению типовой задачи.

- Одну и ту же задачу часто можно решить с использованием разных шаблонов.

- Существует много литературы с описанием различных шаблонов проектирования.

#### Зачем нужно

- Позволяют избежать «типовых» ошибок при разработке типовых решений.
- Позволяют кратко описать подход к решению задачи; программистам, знающим шаблоны, проще обмениваться информацией.
- Легче поддерживать код — его поведение более предсказуемо.
- GoF-паттерны Описаны в книге 1994 г. «Design Patterns: Elements of Reusable Object-Oriented Software» («Приёмы объектно-ориентированного проектирования. Паттерны проектирования»).

__Архитектурные шаблоны__

- Более высокий уровень по сравнению с шаблонами проектирования.
- Описывают архитектуру всей системы или приложения.
- Обычно имеют дело не с отдельными классами, а с целыми компонентами или модулями.
- Компоненты и модули могут быть построены с использованием различных шаблонов проектирования.

###3. Jquery ajax запрос на сервлет, ответ от сервлета - объект json, вывести на страницу firstname, lastname, img_url

```js

var userObj = {
    "userName": "vlad"
}

var userJson = JSON.stringify(userObj);


$.ajax({
    url: url,
    method: "post",
    data: userObj,
    error: function(message) {
        console.log(message);
    },
    success: function(data) {
        console.log(data.firstname);
        console.log(data.lastname);
        console.log(data.img_url);
    }
});

```
## Билет 7

###1. DOM и BOM

__DOM__ - программный интерфейс для HTML и XML документов, описывающий структурированное представление документа и определяющий, как это структура может быть доступна из программ, которые могут изменять ее содержимое.

Согласно DOM документ может быть представлен в виде объектов, с которыми можно производить манипуляци:

1. генерация и добавление узлов
2. получение узлов
3. изменение узлов
4. изменение связей между ними
5. удаление узлов

__BOM__ - объектная модель браузера. Основное предназначение — управление окнами браузера и обеспечение их взаимодействия. BOM специфична для каждого браузера. Может создавать системные диалоги, управлять информацией о параметрах монитора и браузера и т.д.

Обращение к узлам происходит с помощью элементов document (DOM) или window (BOM).

```js
var contentsWindow;
contentsWindow = window.open("http://cs.ifmo.ru","contents");
```
__Возможности BOM:__

- управление фреймами,
- поддержка задержки в исполнении кода изацикливания с задержкой,
- системные диалоги,
- управление адресом открытой страницы,
- управление информацией о браузере,
- управление информацией о параметрах монитора,
- ограниченное управление историей просмотра страниц,
- поддержка работы с HTTP cookie

###2. Управление сессией. HttpSession.

__Сеанс (сессия)__ – соединение между клиентом и сервером, устанавливаемое на определенное время, за которое клиент может отправить на сервер сколько угодно запросов. Сеанс устанавливается непосредственно между клиентом и Web-сервером. Каждый клиент устанавливает с сервером свой собственный сеанс.

Чтобы открыть новый сеанс, используется метод getSession() интерфейса HttpServletRequest. Метод извлекает из переданного в сервлет запроса объект сессии класса HttpSession, соответствующий данному пользователю.

Чтобы сохранить значения переменной в текущем сеансе, используется метод setAttribute(), прочесть – getAttribute(), удалить – removeAttribute(). Список имен всех переменных, сохраненных в текущем сеансе, можно получить, используя метод Enumeration getAttributeNames().

Есть 3 способа отслеживания сессии: cookies, переопределяемый URL (используется response.encodeURL() для каждой ссылки, который вставляет идентификатор сессии в каждый URL.), cкрытые поля форм.

###3. Написать JS-функцию, которая запрещает вводить любые символы, кроме цифр и букв латинского алфавита

```js
function fixValue(){                                                                                                                     
        if (this.value.match(/[^a-z0-9]/ig) !== null)                                                                                     
                this.value = '';                                                                                                         
}                                                                                                                                        
                                                                                                                                         
function setValidation(){                                                                                                                
        let inputs = document.querySelectorAll('input[type=text], input[type=email], input[type=password], textarea');                   
        Array.from(inputs).forEach(                                                                                                      
                input => {                                                                                                               
                        input.addEventListener('input', fixValue)                                                                        
                }                                                                                                                        
        );                                                                                                                               
}
```
## Билет 8

###1. CSS : назначение, правила, приоритеты

CSS - формальный язык описания внешнего вида документа с помощью языка разметки.

Каскадные таблицы стилей используются создателями веб-страниц для задания цветов, шрифтов, расположения и других аспектов представления веб-документа. Основной целью разработки CSS являлось разделение содержимого (написанного на HTML или другом языке разметки) и оформления документа (написанного на CSS). Это разделение может увеличить доступность документа, предоставить большую гибкость и возможность управления его представлением, а также уменьшить сложность и повторяемость в структурном содержимом. Кроме того, CSS позволяет представлять один и тот же документ в различных стилях или методах вывода, таких как экранное представление, печать, чтение голосом (специальным голосовым браузером или программой чтения с экрана), или при выводе устройствами, использующими шрифт Брайля.

Селекторы - элемент, к которому применяется правило.

Основные виды селекторов:
- \* - любые элементы
- div элементы с тегом div
- \#id - элемент по id
- .class - элементы с классом class
- [name="value"] - селекторы по атрибуту
- :visited - псевдоклассы
- div p - элементы p, являющиеся потомками div
- div > p – только непосредственные потомки
- div ~ p – правые соседи: все p на том же уровне вложенности, которые идут после div
- div + p – первый правый сосед: p на том же уровне вложенности, который идёт сразу после div

Структура - правила, селекторы

- Селектор (Selector). Селектор — это элемент, к которому будут применяться назначаемые стили. Это может быть тег, класс или идентификатор объекта гипертекстового документа.
- Свойство (Property). Свойство определяет одну или несколько характеристик селектора. Свойства задают формат отображения селектора: отступы, шрифты, выравнивание, размеры и т.д.
- Значение (Value). Значения — это фактические числовые или строковые константы, определяющие свойство селектора.
- Описание (Declaration). Совокупность свойств и их значений.
- Правило (Rule). Полное описание стиля (селектор + описание).

Таким образом, таблица стилей — это набор правил, задающих значения свойств селекторов, перечисленных в этой таблице.

Приоритеты правил.

- !important позволяет повысить приоритет стиля
- Самый высокий приоритет имеет атрибут style.
- Второе по приоритету - присутствие ID в селекторе.
- Все атрибуты (включая class и псевдоклассы)
- Самый низкий - селекторы с именами элементов и псевдоэлементами.

###2. MVC : назначение, элементы, примеры реализации

__Model-View-Controller__ — схема разделения данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо.

- Модель (Model) предоставляет данные и методы работы с ними: запросы в базу данных, проверка на корректность (не зависит от представления (не знает как данные визуализировать) и контроллера (не имеет точек взаимодействия с пользователем).
- Представление (View) отвечает за получение необходимых данных из модели и отправляет их пользователю (не обрабатывает введённые данные пользователя).
- Контроллер (Controller) обеспечивает «связи» между пользователем и системой. Контролирует и направляет данные от пользователя к системе и наоборот.

Пример: JSF

###3. Реализовать функцию на JavaScript, которая будет закрывать текущее окно, если в нем открыт https://www.google.ru

```js
function close(){
    let url = window.location.href;
	let isGoogle = url.match(/https:\/\/www.google.ru/ig);
    if (isGoogle)
    	window.close();     
}
```
## Билет 9

###1. AJAX и DHTML - описание, сходства и различия

__Asynchronous Javascript and XML__ - подход к построению интерактивных пользовательских интерфейсов веб-приложений, заключающийся в «фоновом» обмене данными браузера с веб-сервером и динамическом обновлением контента.

Реализация AJAX с подощью JQuery:

```js
$.ajax({
  type: "POST",
  url: "some.php",      // обращение к some.php
  data: {name: 'John', location: 'Boston'},   //с какими-то параметрами
  success: function(msg){
    alert( "Data Saved: " + msg );  // получный результат выводится в alert
  }
}); 
```

__DHTML__ - технология создания интерактивных динамических веб-страниц с использованием стандартных средств: html, css, DOM и js. Построен на DOM.

```html
<html>
<head>
    ...
</head>
<body>
<H2>Всплывание события</H2>
<b>Для получения информации можно нажать на изображение или текст</b><br>
<a href="kuda.htm"><img src="be.gif" align="left">Кто это?</a> 
</body>
</html>
```


AJAX позволяет не перезагружать открытую пользователем страницу целиком при внесении в неё каких-либо небольших изменений сервером, а ограничиться загрузкой только небольшого фрагмента.

AJAX-страницы для придания им большей интерактивности реализуются с использованием DHTML, однако DHTML-страницы совершенно не обязательно используют AJAX.

DHTM это различные выпадающие меню на сайтах, разворачивающиеся по клику пользователя панели и древовидные списки, и т. п. Технически Dynamic HTML реализуется с помощью JavaScript, CSS и DOM.

###2. Какие проблемы возникают при параллельной обработке запросов в JSP, как этого можно избежать?

Согласно спецификации сервлетов, web контейнер по умолчанию позволяет одному и тому же экземпляру сервлета параллельно обрабатывать запросы сразу от нескольких клиентов. При этом каждому из запросов выделяется отдельный трэд.

За это отвечает директива isThreadSafe, дефолтное значение которого - true. Для того, чтобы запретить параллельную обработку запросов необходима директива isThreadSafe со значением false.

```jsp
<%@ page isThreadSafe=false %>
```

###3. Написать js функцию, которая заменяет содержимое \<div> с именем класса “nyan” на изображение по ссылке: http://www.example.com/nyancat.gif 

```js
function replaceWithNyan(){                                                       
        let img = document.createElement('img');                                  
        img.src = 'http://www.example.com/nyancat.gif';                           
        Array.from(document.querySelectorAll('.nyan')).forEach(                   
                div => {                                                          
                        div.innerHTML = '';                                       
                        div.appendChild(img);                                     
                }                                                                 
        );                                                                        
}
```

##Билет 10

### 1. Rest и RPC

REST - архитектурный стиль взаимодействия компонентов приложения в сети.

В приложениях, которые поддерживают использование различных клиентов (коды клиентов мб на разных яхыках) пригодится REST. Т.к. Клиенты очень разные, но нам нужно, чтобы они понимали друг друга.

REST - набор правил: как программисту организовать написание кода серверного веб-приложения, чтобы все системы легко обменивались данными и прилржение могло было масштабироваться

Требования к архитекруте REST:

- Модель клиент-сервер
- Отсутствие состояния (в период между запросами клиента никакая информация о состоянии клиента на сервере не хранится)
- Кэширование (клиенты могут выполнять кэширование ответов с сервера, ответы должны иметь обозначения как кэшируемые или нет для избежания получения неверных последующих ответов)
- Единообразие интерфейса
- Слои (сервера, какие-то промежуточные сервера и узлы)

RPC - удалённый вызов процедур. 

- Нацелен на передачу управления и данных через сеть (т.е. используются разные машины) -> будет полезен в типах приложений, в кот. присутсвуют удаленные компоненты (разные машины), которые необходимо связать интерактивно

Что-то вроде совокупности клиент-серверного приложения с сериализацей объектов.

### 2. RequestDispatcher

####Диспетчеризация запросов в сервлетах

- Сервлеты могут делегировать обработку запросов другим ресурсам (сервлетам, JSP и HTML-страницам).
- Диспетчеризация осуществляется с помощью реализаций интерфейса javax.servlet.RequestDispatcher.
- Два способа получения RequestDispatcher — через ServletRequest (абсолютный или относительный URL) (RequestDispatcher view = request.getRequestDispatcher(“result.jsp”);) и ServletContext (только абсолютный URL). (RequestDispatcher reqDispObj = getServletContext().getRequestDispatcher("/ContextRoot/home.jsp");)
- Два способа делегирования обработки запроса — forward и include (include используется чтобы вставить вывод другого сервлета в текущий. forward позволяет провести предварительную обработку запроса и потом полностью передать управление другому сервлету)

####Отличие include от forward:

Assume you have two pages, pageA, and pageB. In pageA you wrote the include tag. In this case the control was in pageA til you called the include tag. At this point the full control goes to pageB. When It's done, control is returned to pageA starting from the next point of coding after the include tag and continuing to the rest of pageA.

Well, to get things much clearer, let's say that we have the same pages, pageA and pageB, but this time we will use the forward tag in pageA, not the include tag. Again, the control will begin in pageA till we call the forward tag in pageA, at this point, control is transfered to pageB, just like the include tag. But the difference is what happens when pageB completes. In case of the forward tag, control doesn't go back to pageA again.

####Отличие redirect от forward:

response.sendRedirect(""); используется для перенаправления ресурсов на разные серверы или домены. Эта передача задачи управления делегируется браузеру контейнером. То есть, перенаправление отправляет заголовок обратно в браузер/клиент. Этот заголовок содержит URL-адрес ресурса, который будет перенаправлен браузером. Затем браузер инициирует новый запрос к указанному URL-адресу.

request.getRequestDispathcer("login.jsp").forward(request, response); используется для пересылки ресурсов, доступных на сервере, с которых выполняется вызов. Эта передача управления осуществляется контейнером внутри, а браузер/клиент не задействован.

мы должны использовать forward() при доступе к ресурсам в том же приложении, потому что это быстрее, чем метод sendRedirect(), который требовал дополнительного сетевого вызова.

### 3. Правило css, меняющее цвет фона на желтый, если ссылка посещена и не лежит в классе “news” 

```css
/* Правило css, меняющее цвет фона на желтый, если ссылка посещена и не лежит в классе "news": */
*:not(.news)>a:visited {
	color: yellow;
}


```

##Билет 11

###1. javascript, особенности, что для чего и тд

__JavaScript__ является объектно-ориентированным языком.

####Основные архитектурные черты:

- динамическая типизация; (автоматическое приведение типов)
- слабая типизация;
- автоматическое управление памятью; (автоматическая сборка мусора)
- прототипное программирование; (отсутствует понятие класса, а наследование производится путём клонирования существующего экземпляра объекта — прототипа.)
- функции как объекты первого класса. (т.е. мб сохранены в переменную, переданны в функцию как аргумент, созданы во время выполнения программы и т.п.)

###2. JSP actions

JSP actions могут воздействовать на стандартный поток вывода, использовать, модифицировать и создавать объекты используя конструкции XML для управления сервлетом.

JSP - XML-элементы, позволяющие управлять поведением сервлета.

```jsp
<jsp:action_name attribute = "value" />
```
- jsp:include - включает файл при запросе
- jsp:useBean - Добавляет на страницу экземпляр Java Bean с заданным контекстом.
- jsp:setProperty - Получение и установка свойств Java Bean
- jsp:forward - пересылает на другую страницу
- jsp:declaration – объявление, аналогично <%! … %>
- jsp:scriptlet – скриптлет, аналогично <% … %>
- jsp:expression – скриптлет, аналогично <%= … %>
- jsp:text – вывод текста
...

###3. PHP скрипт, который достаёт из get запроса имя и фамилию и приветствует пользователя, выводя html страницу

```php
<?php                                         
$name = $_GET['name'];  
$lastname = $_GET['lastname'];                      
echo 'Hello ' . ($name?$name:'noname') . ' ' . ($lastname?$lastname:'nolastname') . '!'; 
?> 

```

## Билет 12

###1. Cтруктура протокола http, характеристики

HTTP — это протокол, позволяющий получать различные ресурсы, например HTML-документы. Протокол HTTP лежит в основе обмена данными в Интернете. HTTP является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим получателем, обычно веб-браузером (web-browser).

Браузер (клиент) отправляет серверу HTTP запросы, а сервер отправляет клиенту HTTP ответы. Эти запросы и ответы оформляются по определенным правилам. Есть, что-то вроде синтаксиса, как и в какой последовательности, должно быть написано. Должна быть строго определенная структура.

HTTP запрос состоит из трех основных частей, которые идут в нем именно в том порядке, который указан ниже. 

Между заголовками и телом сообщения находится пустая строка (в качестве разделителя), она представляет собой символ перевода строки.

1. Строка запроса (Request Line) - указывает метод передачи, URL-адрес, к которому нужно обратиться и версию протокола HTTP.
2. Зголовки (Message Headers) - описывают тело сообщений, передают различные параметры и др. сведения и информацию.
3. Пустая строка (разделитель)

4. тело сообщения (Entity Body) – сами данные, которые передаются в запросе. необязательный параметр. 
Когда мы получаем ответный запрос от сервера, тело сообщения, чаще всего представляет собой содержимое веб-страницы. Но, при запросах к серверу, оно тоже может иногда присутствовать, например, когда мы передаем данные, которые заполнили в форме обратной связи на сервер.

####Характеристики

- Протокол прикладного уровня
- Основа — технология «клиент-сервер»
- Может быть использован в качестве «транспорта» для других протоколов прикладного уровня
- Основной объект манипуляции — ресурс, на который указывает URI
- Обмен сообщениями идёт по схеме «запрос-ответ»
- Stateless-протокол (один запрос — одно соединение). Для реализации сессий используются cookies.

###2. Жизненный цикл jsp

1. Translation – Трансляция jsp в код сервлета
2. Compilation – Компиляция сервлета
3. Class Loading – Загрузка класса сервлета
4. Instantiation – Создание экземпляра сервлета 
5. Initialization – Вызов метода jspInit()
6. Request Processing – длительный жизненный цикл обработки запросов клиента JSP страницей. Обработка является многопоточной и аналогична сервлетам — для каждого запроса создается новая нить, создаются объекты ServletRequest и ServletResponse и происходит внедрение сервис методов JSP.
7. Destroy – последняя фаза жизненного цикла JSP на которой JSP класс удаляется из памяти. Обычно это происходит при выключении сервера или андеплое приложения.

###3. Написать на php класс

```php
<?php
// сделать класс на php
class User{
    private $userName;
    private $age;
 
    function __constuctor($userName, $age){
        $this->userName = $userName;
        $this->age = $age;
    }
 
    function whois(){
        return 'Name: ' . $this->userName . '\nAge: ' . $this->age;
    }
}
?>
``` 
## Билет 13

###1. Преимущества и недостатки ajax

__Asynchronous Javascript and XML__ - подход к построению интерактивных пользовательских интерфейсов веб-приложений, заключающийся в «фоновом» обмене данными браузера с веб-сервером.

Пользователь что-то делает -> скрипт определяет с чем там надо работать -> браузер отправляет запрос на сервер -> сервер возвращает только то, от чего ожидаются изменения -> скрипт вносит изменения обратно (без перезагрузки страницы).

####Преимущества 

- Экономия трафика пользователя (вместо обновления всей страницы, загружается ее небольшая изменившаяся часть);
- Снижение нагрузки на сервер. К примеру, на странице личных сообщений форума при выделении пользователем прочитанных писем сервер вносит изменения в БД и отправляет скрипту клиента ответ о выполнении операции без повторного создания страницы и ее передачи;
- Ускорение реагирования интерфейса на команды пользователя.
      
####Недостатки 

- Не всегда возможна интеграция со стандартным набором инструментов браузера. Так как интернет-обозреватели не регистрируют в истории переходы по страницам, нельзя воспользоваться кнопкой «Назад». В некоторых случаях нет возможности добавить в закладки нужный материал;
- Контент, загружаемый динамически, не доступен поисковым системам, поэтому необходимо обеспечить альтернативный доступ к содержимому ресурса;
- Неправильный учет статистики перемещения пользователя по сайту
- Усложнение проекта;
- Требуется включенный JavaScript в браузере.

###2. Директива page: назначение, особенности, атрибуты

####Назначение
Позволяет задавать параметры, используемые контейнером при управлении жизненным циклом страницы.

####Особенности
- Обычно расположена в начале страницы.
- На одной странице может быть задано несколько директив page с разными указаниями контейнеру.
- Синтаксис:
<%@ page attribute="value" %>

####Атрибуты

- buffer -  Задаёт параметры буферизации и размер буфера для потока вывода сервлета.
- autoFlush - Указывает, автоматически ли выгружается содержимое буфера при его переполнении.
- contentType - Позволяет задать Content Type и кодировку страницы.
- errorPage - Позволяет задать страницу, на которую будет осуществлено перенаправление при возникновении Runtime Exception.
- isErrorPage - Указывает, является ли текущая страница Error Page.
- extends -  Позволяет задать имя родительского класса, от которого будет наследоваться сервлет.
- import -  Импорт классов или пакетов.
- info - Задаёт строку, которую будет возвращать метод getServletInfo().
- isThreadSafe - Если isThreadSafe == false, то контейнер блокирует параллельную обработку нескольких запросов страницей.
- language - Позволяет задать язык программирования, на котором пишутся скриптовые элементы на странице (по умолчанию — Java).
- session - Указывает контейнеру, создавать ли ему предопределённую переменную session.
- isELIgnored - Указывает, вычисляются EL-выражения контейнером, или нет.
- isScriptingEnabled Указывает, обрабатываются ли скриптовые элементы.
    
###3. Написать конфигурацию сервлета (org.xxx.MyServlet) с помощью аннотации. Сервлет должен принимать все запросы от файлов .html .xhtml

```java
@WebServlet(urlPatterns = {"*.xhtml", "*.html"})
public class MyServlet {
}
```
## Билет 14

###1. Cтруктура http запроса

HTTP — это протокол, позволяющий получать различные ресурсы, например HTML-документы. Протокол HTTP лежит в основе обмена данными в Интернете. HTTP является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим получателем, обычно веб-браузером (web-browser).

Браузер (клиент) отправляет серверу HTTP запросы, а сервер отправляет клиенту HTTP ответы. Эти запросы и ответы оформляются по определенным правилам. Есть, что-то вроде синтаксиса, как и в какой последовательности, должно быть написано. Должна быть строго определенная структура.

HTTP запрос состоит из трех основных частей, которые идут в нем именно в том порядке, который указан ниже. 

Между заголовками и телом сообщения находится пустая строка (в качестве разделителя), она представляет собой символ перевода строки.

1. Строка запроса (Request Line) - указывает метод передачи, URL-адрес, к которому нужно обратиться и версию протокола HTTP.
2. Зголовки (Message Headers) - описывают тело сообщений, передают различные параметры и др. сведения и информацию.
3. Пустая строка (разделитель)

4. тело сообщения (Entity Body) – сами данные, которые передаются в запросе. необязательный параметр. 
Когда мы получаем ответный запрос от сервера, тело сообщения, чаще всего представляет собой содержимое веб-страницы. Но, при запросах к серверу, оно тоже может иногда присутствовать, например, когда мы передаем данные, которые заполнили в форме обратной связи на сервер.


###2. Типы данных php

PHP - яп с динамической типизацией. Преобразования меджду скалярными типами происходят неявно.

Скалярные типы: integer, float, double, boolean, string.

Нескалярные: array, object, resource, null

Псевдотипы: mixed (любой тип), number, callback (string или анонимная фунуция), void.

###3. Сервлет перенаправляющий все запросы на страницу google 

```java
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import java.io.IOException;
 
// Написать сервлет, который будет возвращать все запросы на переадресацию на сайт google.com
 
class ToGoogleServlet extends HttpServlet{
        public void service(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException{
                response.sendRedirect("http://google.com");
        }
}

```

## Билет 15

###1. Php, особенности и запуск

__PHP__ (PHP: Hypertext Preprocessor) — скриптовый язык, часто используемый для написания вебприложений.

- Конфигурационные параметры хранятся в файле php.ini.
- Можно подключать дополнительные модули, расширяющие возможности языка (например, добавляющие поддержку взаимодействия с СУБД).
 
Способы использования интерпретатора PHP:
- С помощью SAPI / ISAPI (например, mod_php для
Apache).
- С помощью CGI / FastCGI.
- Через интерфейс командной строки.


###2. Long Polling vs WebSockets

__Long Polling__ — это технология, которая позволяет получать данные о новых событиях с помощью «длинных запросов». Сервер получает запрос, но отправляет ответ на него не сразу, а лишь тогда, когда произойдет какое-либо событие (например, придёт новое сообщение), либо истечет заданное время ожидания.

- Клиент запрашивает страницу у сервера, используя обычный http
- Запрошенная страница выполняет JavaScript, который запрашивает файл от сервера.
- Сервер НЕ реагирует на запрошенную информацию и ждет, пока не появится новой информации
- Когда появляется новая информация, сервер отсылает ее клиенту
-  лиент получает новую информацию и сразу отсылает другой запрос серверу, запуская процесс ожидания на нем снова.

__WebSocket__ — протокол полнодуплексной связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и вебсервером в режиме реального времени.

- Клиент запрашивает страницу у сервера, используя обычный http
- Открывается соединение с сервером
- Сервер и клиент могут посылать друг другу сообщения

__Обмен данными ведётся через отдельное TCPсоединение.__

####Преимущества WebSocket:
- Поддерживается всеми современными браузерами (даже IE).
- Не требуется рвать соединение при доставки сообщения.
- (Следствие второго) можно отправлять больше сообщений пользователю в секунду
- Можно самостоятельно отправлять серверу сообщения по WebSockets, то есть, общение двустороннее.

###3. Написать JSP страницу, которая будет возвращать количество сессий, обратившихся к ней за последние 60 секунд и формировать вывод в HTML

```java
public class var6 extends HttpServlet {
 Date d;
 ArrayList<HttpSession> s = new
 ArrayList<HttpSession>();
 Predicate<HttpSession> isOld = new Predicate<HttpSession>() {
  @Override
  public boolean test(HttpSession t) {
   try {
      return ((d.getTime()-t.getLastAccessedTime())) > 6000;
   }
  catch(IllegalStateException e) {
  return true;
  }}
 };

protected void srvice(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
 response.setContentType("text/html;charset=UTF8");
 int i;
 d = new Date();
 s.removeIf(isOld);
 if((i = s.indexOf(request.getSession())) > -1)
 s.remove(i);
 s.add(request.getSession());
 try (PrintWriter out = response.getWriter()) {
 out.println("<!DOCTYPE html>");
 out.println("<html>");
 out.println("<head>");
 out.println("<title>Servlet var6</title>");
 out.println("</head>");
 out.println("<body>");
 out.println("<b>Count Sessions:" +
 Integer.toString(s.size()) + "</b>");
 out.println("</body>");
 out.println("</html>");
 } 
 }}
```

##Билет 16

###1. Элементы JSP

2 варианта синтаксиса — на базе HTML и XML.

- Обозначаются тегами <% %> (HTML-вариант):
<html>
<%-- scripting element --%>
</html>
        
- Существует 5 типов JSP-элементов:
- Комментарий — <%-- Comment --%>;

  Поддерживаются 3 типа комментариев:
  * HTML-комментарии:
  <!-ч- This is an HTML comment.
  It will show up in the response. -ч->
  * JSP-комментарии:
  <%-- This is a JSP comment.
  It will only be seen in the JSP code.
  It will not show up in either the servlet code
  or the response.
  --%> 
  * Java-комментарии:
  <%
  /* This is a Java comment.
  It will show up in the servlet code.
  It will not show up in the response. */
  %>

- Директива — <%@ directive %>;

  Управляют процессом трансляции страницы в сервлет.
    * Директива страницы (Директива страницы используется для предоставления инструкций контейнеру. Эти инструкции относятся к текущей странице JSP.)
    <%@ page session=”false” %>
    <%@ page import="java.util.ArrayList" %>
    <%@ page import="helpers.Point" %>
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    (buffer, contentType, language, isThreadSafe)
    * Директива включения (Директива include используется для включения файла на этапе перевода. Эта директива указывает контейнеру объединять содержимое других       внешних файлов с текущим JSP на этапе трансляции.)
    <%@ include file=”incl/copyright.html” %> 
    Эквивалент на XML:<jsp:directive.include file="url"\>.
    URL должен быть относительным . Для подключения файла в процессе запроса а не в ходе трансляции используйте действие jsp:include.
       1) Директива include :
       <%@ include file="header.html" %>
       Статический : добавляет содержимое из значения атрибута файла на текущую страницу во время перевода . Директива изначально предназначалась для статических          шаблонов макета, таких как заголовки HTML.

      2) <jsp:include> Стандартное действие :
      <jsp:include page="header.jsp" />
      Динамический : добавляет содержимое из значения атрибута страницы на текущую страницу во время запроса . Был предназначен больше для динамического контента,       поступающего из JSP.

      3) <c:import>Тег JSTL:
      <c:import url=”http://www.example.com/foo/bar.html” />
      Динамический : добавляет содержимое из значения атрибута URL на текущую страницу во время запроса . Он работает примерно так же <jsp:include>, но он более         мощный и гибкий: в отличие от двух других включений, <c:import> URL-адрес может быть извне веб-контейнера !
    
    * Директива taglib ( Библиотеки тегов-это фрагменты кода Java, которые могут использоваться в JSP, но которые соответствуют определенному API и которые             выглядят как теги HTML в JSP. Файл описания библиотеки тегов (TLD) описывает имена этих тегов, какие атрибуты они могут иметь и какие классы Java реализуют их)
    
    Директива taglib имеет следующий синтаксис: 
    <%@ taglib uri="URI включаемой библиотеки тегов" prefix="имяПрефикса" %>
    Префикс "имяПрефикса" используется при обращении к библиотеке. Пример использования библиотеки тегов mytags:
    <%@ taglib uri="http://www.taglib/mytags" prefix="customs" %>
    . . .
    <customs:myTag>
    
- Объявление — <%! decl %>;(declarations не производят никакого вывода в стандартный выходной поток out. Переменные и методы, декларированные в объявлениях, инициализируются и становятся доступными для скриптлетов и других объявлений в момент инициализации страницы JSP.)

    Позволяют объявлять поля и методы:
    * Синтаксис:
    ```jsp
    <%! JavaClassDeclaration %>
    ```
    * Примеры:
    ```jsp
    <%!
    public static final String DEFAULT_NAME = “World”;
    %>
    <%!
    public String getName(HttpServletRequest request) {
    return request.getParameter(“name”);
    }
    %>
    <%! int counter = 0; %>
    ```
    
- Скриптлет — <% code %>; (Позволяют задать Java-код, который будет выполняться при обработке запросов (при вызове метода _jspService).)
    * Синтаксис:
    ```jsp
    <% JavaCode %>
    ```
    * Примеры:
    ```jsp
    <% int i = 0; %>
    <% if ( i > 10 ) %>
    I am a big number
    <% } else { %>
    I am a small number
    <% } %>
    ```

- Выражение — <%= expr %>. (Позволяют вывести результат вычисления выражения.)
    * Синтаксис:
    ```jsp
    <%= JavaExpression %>
    ```
    * Примеры:
    ```
     <B>Ten is <%= (2 * 5) %></B>
     Thank you, <I><%= name %></I>, for registering for the soccer league.
     The current day and time is: <%= new java.util.Date() %>
     ```

###2. CGI - обработка запроса, преимущества и недостатки

__CGI__ (Common Gateway Interface — общий интерфейс шлюза) — стандарт интерфейса, используемого для связи внешней программы с веб-сервером. Программу, которая работает по такому интерфейсу совместно с веб-сервером, принято называть шлюзом (оно же скрипт или CGI-программа). По сути позволяет использовать консоль ввода и вывода для взаимодействия с клиентом.

__Обобщенный алгоритм работы через CGI можно представить в следующем виде:__

- Клиент запрашивает CGI-приложение по его URI.
- Веб-сервер принимает запрос и устанавливает переменные окружения, через них приложению передаются данные и служебная информация.
- Веб-сервер перенаправляет запросы через стандартный поток ввода (stdin) на вход вызываемой программы.
- CGI-приложение выполняет все необходимые операции и формирует результаты в виде HTML.
- Сформированный гипертекст возвращается веб-серверу через стандартный поток вывода (stdout). Сообщения об ошибках передаются через stderr.
- Веб-сервер передает результаты запроса клиенту.

####Преимущества CGI
- Процесс CGI скрипта не зависит от Веб-сервера и, в случае падения, никак не отразится на работе последнего
- Может быть написан на любом языке программирования
- Поддерживается большинством Веб-серверов
####Недостатки
- Самым большим недостатком этой технологии являются повышенные требования к производительности веб-сервера. Дело в том, что каждое обращение к CGI-приложению вызывает порождение нового процесса, со всеми вытекающими отсюда накладными расходами. Если же приложение написано с ошибками, то возможна ситуация, когда оно, например, зациклится. Браузер прервет соединение по истечении тайм-аута, но на серверной стороне процесс будет продолжаться, пока администратор не снимет его принудительно.

###3. Написать сервлет, который принимает из http запроса параметр name и выводит его. Если параметр не обнаружен то вывести Anonymous user 

```java
import java.io.PrintWriter;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServleResponse;
 
 
class HelloServlet extends HttpServlet{
        public void service(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException{
            response.setContentType("text/html; charset=UTF-8");
 
                String name = request.getParameter("name");
                PrintWriter out = response.getWriter();
 
                name = name==null?"Anonymous user":name;
                out.println("<h1>Hello " + name + "</h1>");
                out.close();
        }
}
```

##Билет 17

###1. FastCGI. Плюсы, минусы, отличия от CGI

Дальнейшее развитие технологии CGI, является более производительным и безопасным, снимает множество ограничений CGI-программ.

CGI — устаревшая технология, позволяющая взаимодействовать веб-серверу с сервером приложений. Для каждого запроса запускается процесс с интерпретатором PHP, после возвращения ответа он завершается. Поскольку это очень неэффективно, был создан FastCGI, в котором процесс интерпретатора не завершается, а используется для последующих запросов.

####Особенности технлогии
FastCGI программа работает следующим образом: программа единожды загружается в память в качестве демона (независимо от HTTP-сервера), а затем входит в цикл обработки запросов от HTTP-сервера. Один и тот же процесс обрабатывает несколько различных запросов один за другим, что отличается от работы в CGI-режиме, когда на каждый запрос создается отдельный процесс, "умирающий" после окончания обработки.

####Недостатки
Написание FastCGI программ-демонов сложнее чем CGI, нужны дополнительные библиотеки, зависящие от языка.


###2. Суперглобальные массивы в PHP (SuperGlobal massive)

Есть предопределенные (не надо явно указывать global $var) массивы (и переменные), которые доступны в любом месте скрипта.

- $GLOBALS : ссылки на все переменные глобальной области видимости
- $_SERVER : заголовки, пути и местоположения скриптов.
- $_GET : переменные GET-запроса
- $_POST : переменные POST-запроса
- $_FILES : переменные файлов, загруженных по HTTP
- $_COOKIE : переданные скрипту через HTTP Cookies.
- $_SESSION : переменные сессии
- $_REQUEST : по умолчанию содержит данные переменных $_GET, $_POST и $_COOKIE
- $_ENV : переменные окружения

###3. Страница JSP, проверяющая есть ли /какой-то параметр/ в запросе и если нету - выводящая сообщение об ошибке 

```jsp
<%-- Страница JSP, проверяющая есть ли /какой-то параметр/ в запросе и если нету - выводящая сообщение об ошибке  --%>
 
<%@ page contentType="text/html; charset=UTF-8" language="java"%>
<%= request.getParameter("parameterName")==null?"400 - your did not set parameter":request.getParameter("parameterName")  %>

``` 
##Билет 18

###1. ООП в PHP

PHP поддерживает все три основных механизма ООП — инкапсуляцию, полиморфизм подтипов и наследование (с помощью extend). Поддерживаются интерфейсы (с помощью implements). Есть абстрактные и final методы и классы. Множественное наследование не поддерживается, но класс может реализовывть несколько интерфейсов или с помощью механизма особенностей (trait), который имеет средства для разрешения конфликтов.

Методы: __construct() -- конструктор __destruct() -- для деинициализации объекта __get(), __set() __sleep(), __wakeup() __clone()


###2. Предопределенные переменные JSP

В процессе трансляции контейнер добавляет в метод _jspService ряд объектов, которые можно использовать в скриптлетах и выражениях:

- request : HttpServletRequest -- позволяет обращаться к параметрам запроса (через метод getParameter), типу запроса (GET, POST, HEAD) и входящим HTTP заголовкам (cookies, Referer)
- response : HttpServletResponse
- out : PrintWriter -- для отправки вывода клиенту
- session : HttpSession
- application : ServletContext
- config : ServletConfig -- для текущей страницы
- page : синоним this
- pageContext
- exception: java.lang.Throwable ( используется только на страницахперенаправлениях с информацией об ошибках (Error Pages).)


###3. Код фильтра запросов, запрещающий доступ к приложению неавторизированным пользователям(у неавт пол в запросе отсутствует заголовок x-application-user)

```java
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
 
// Код фильтра запросов, запрещающий доступ к приложению неавторизированным
// пользователям(у неавт пол в запросе отсутствует заголовок x-application-user)
 
class AuthFilter extends ServletFilter{
        public void init(FilterConfig config){}
 
        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException{
                String auth = request.getHeader("x-application-user");
                if (auth == null || auth.equals("")){
                        PrintWriter out = response.getWriter();
                        response.setContentType("text/html; charset=UTF-8");
                        out.println("WTF?! You are not authorized");
                }else{
                        chain.doFilter(request, response);
                }
 
        }
 
        public void destroy(){}
}
``` 

##Билет 19

Билет 19

###1. Конфигурация PHP-интеррпретатора, способы интеграции PHP-интеррпретатора с веб-сервером

__PHP__ (PHP: Hypertext Preprocessor) — скриптовый язык, часто используемый для написания вебприложений.

- Конфигурационные параметры хранятся в файле php.ini.
- Можно подключать дополнительные модули, расширяющие возможности языка (например, добавляющие поддержку взаимодействия с СУБД).
 
Способы использования интерпретатора PHP:
- С помощью SAPI / ISAPI (например, mod_php для
Apache).
- С помощью CGI / FastCGI.
- Через интерфейс командной строки.


###2. ServletContext - особенности, для чего нужен

ServletContext живет до тех пор, пока живет веб-приложение. Он является общим для всех запросов во всех сеансах.

###3. Код jsp-страницы показывающий содержимое корзины юзера. Содержимое корзины - коллекциия объектов класса ShoppingItem который содержит имя, стоимость и количество заказанного товара - хранится в отдельном managed bean. 

```jsp
<%@ import="my.package.ShoppingItem" %>
<%@ import="java.util.Collection" %>
<%@ contentType="text/html;charset=UTF-8" language="java"%>
<jsp:useBean id="managed" class="my.package.ManagedBean" scope="session">
<html>
<head>
        <meta charset="utf-8">
</head>
<body>
<table>
        <tr>
                <th>name</th>
                <th>price</th>
                <th>count</th>
        </tr>
<%
        Collection<ShoppingItem> basket = mananged.getBasket();
        for (ShoppingItem position: basket){%>
                <tr>
                        <td><%= position.getName() %></td>
                        <td><%= position.getPrice() %></td>
                        <td><%= position.getCount() %></td>
                </tr>
        <%}%>
</table>
</body>
```

##Билет 20

##1. HTML формы

Форма предназначена для обмена данными между пользователем и сервером.

Задается с помощью тега и могут содержать в себе атрибуты: action, содержищий URI обработчика формы (обязательный атрибут), method (по умолчанию, GET), enctype (тип кодирования), accept (MIME-типы для загрузки файлов), name, onsubmit/onreset (обработчик события submit/reset для скриптов), accept-character.

Виды полей:

- Кнопка . Типы кнопок , , , .
- Checkbox.
- Radio.
- Select.
- Text и многострочный textarea.
- Password.
- Hidden (скрытое поле).
- File.


##2. конфигурация сервлетов. файл web.xml

Java веб-приложения используют файл дескриптора развертывания web.xml для определения какие URL будут передаваться определенному сервлету, какие URL требуют аутентификации. Дескриптор развертывания веб-приложений описывает классы, ресурсы и конфигурацию приложения, а так же как сервер будет использовать их для выполнения веб-запросов.

```xml
 <servlet>
        <servlet-name>redteam</servlet-name>
        <servlet-class>mysite.server.TeamServlet</servlet-class>
        <init-param>
            <param-name>teamColor</param-name>
            <param-value>red</param-value>
        </init-param>
    </servlet>
```
   
Oпределяет соответствие между путями URL и сервлетами

```xml
 <servlet-mapping>
        <servlet-name>redteam</servlet-name>
        <url-pattern>/red/*</url-pattern>
 </servlet-mapping>
```


##3. написать css правило, которое при клике на ссылку добавляет ей подчеркивание, всем кроме ссылок в теге h1 (Возможный ответ)

```css
/* Написать css правило, которое при клике на ссылку добавляет ей подчеркивание, всем кроме ссылок в теге h1 */
*:not(h1)>a:active {
	text-decoration: underline;
}
```





















